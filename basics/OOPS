ðŸ”· What is an Interface in Java?

âœ… Interface in Java â€“ Key Points (Corrected & Simple)

â€¢ Interface is a reference type in Java.

â€¢ It does not have method implementation (only abstract methods).

â€¢ All methods in an interface are abstract by default.

â€¢ We cannot create an object of an interface.

â€¢ Interface is used to achieve 100% abstraction.

â€¢ Interface cannot have a constructor (because no object creation).

â€¢ It supports multiple inheritance.

â€¢ We use the implements keyword to implement an interface in a class.

â€¢ To achieve abstraction in Java, we commonly use interfaces.

â€¢ Interface methods are public by default, so the interface itself cannot be private.


âš¡ Real-time Example (Company based)

Payment System

interface Payment {
    void pay();
}

class GPay implements Payment {
    public void pay() {
        System.out.println("Paid using GPay");
    }
}

class PhonePe implements Payment {
    public void pay() {
        System.out.println("Paid using PhonePe");
    }
}

Interface is used for security by hiding implementation details and exposing only necessary methods.
It provides abstraction, controlled access, and loose coupling, which makes the system safer and flexible.

---

ðŸ”¹ Types of Methods in Java
ðŸ‘‰ Mainly two types:
1ï¸âƒ£ Predefined Method
2ï¸âƒ£ User-defined Method

And inside user-defined methods, we have:

ðŸ‘‰ Static Method
ðŸ‘‰ Instance Method

---

âœ… 1. Predefined Methods (Built-in)

These are already provided by Java.

ðŸ“Œ Examples:
System.out.println();
Math.sqrt(16);


ðŸ‘‰ Created by Java developers
ðŸ‘‰ We just use them

---

âš¡ Static Method

ðŸ‘‰ Belongs to class
ðŸ‘‰ No object needed
ðŸ‘‰ Called using class name

âœ” Example:
class Demo {
    static void display() {
        System.out.println("Static Method");
    }

    public static void main(String[] args) {
        Demo.display();   // no object
    }
}

---

ðŸ‘¤ Instance Method (Non-static)

ðŸ‘‰ Belongs to object
ðŸ‘‰ Object is required
ðŸ‘‰ Called using object

âœ” Example:
class Demo {
    void show() {
        System.out.println("Instance Method");
    }

    public static void main(String[] args) {
        Demo d = new Demo();
        d.show();   // using object
    }
}

---

ðŸ” How is Data Hiding done in Java?

ðŸ‘‰ By using private access modifier

and

ðŸ‘‰ Accessing using public methods (getter & setter)

With Data Hiding (Safe âœ…)
class Account {
    private int balance = 10000; // USE private modifier

    public void setBalance(int amount) {
        if(amount > 0) {
            balance = amount;
        }
    }

    public int getBalance() {
        return balance;
    }
}

Data Hiding is the process of protecting class data by declaring variables as private 
and providing controlled access through public methods(GET AND SET METHODS).

---

ðŸ”’ What is Encapsulation in Java?

Encapsulation = Wrapping data(Instance variable) and behaviour(Instance method) together as a single unit.
and restricting access to variable directly.

Wrapping data (variables) and methods together in one class and protecting the data from direct access.

ðŸ‘‰ We do this by:
Making variables private
Accessing them using public getter and setter methods

âœ… Java Real-Time Example
class BankAccount {

    private int balance;   // hidden data  (instance variable should be private to achieve encapsulation)

    // deposit method
    public void deposit(int amount) {
        if(amount > 0) {
            balance = balance + amount;
        }
    }

    // withdraw method
    public void withdraw(int amount) {
        if(amount <= balance) {
            balance = balance - amount;
        }
    }

    // check balance
    public int getBalance() {
        return balance;
    }
}

â–¶ Using it:
public class Main {
    public static void main(String[] args) {

        BankAccount acc = new BankAccount();

        acc.deposit(1000);
        acc.withdraw(300);

        System.out.println(acc.getBalance()); // 700
    }
}

---

ðŸ”§ What is a Constructor in Java?

ðŸ‘‰ A constructor is a special method that runs automatically when an object is created.

Its main job:
âœ… Initialize values
âœ… Prepare object to use

ðŸ‘‰ Name = class name
ðŸ‘‰ No return type (not even void)

1ï¸âƒ£ Default Constructor (no arguments)

ðŸ‘‰ Automatically called when you create object without values.

âœ” Real life:

Opening app â†’ shows default welcome screen

Java Example:
class Food {
    String name;

    // Default constructor
    Food() {
        name = "Unknown Food";
        System.out.println("Default constructor called");
    }
}

class Main {
    public static void main(String[] args) {
        Food f1 = new Food();   // calls default constructor
        System.out.println(f1.name);
    }
}

Output:
Default constructor called
Unknown Food
---

2ï¸âƒ£ Parameterized Constructor (with values)

ðŸ‘‰ Used to set values while creating object.

âœ” Real life:

Ordering food â†’ you choose name & type

Java Example:
class Food {
    String name;
    int category;

    // Parameterized constructor
    Food(String name, int category) {
        this.name = name;
        this.category = category;
    }
}

class Main {
    public static void main(String[] args) {
        Food f1 = new Food("Dosa", 1);

        System.out.println(f1.name);
        System.out.println(f1.category);
    }
}

Output:
Dosa
1
---

3ï¸âƒ£ Copy Constructor

ðŸ‘‰ Copies data from one object to another.

âœ” Real life:

Re-order same food again ðŸ•

Java Example:
class Food {
    String name;

    // Normal constructor
    Food(String name) {
        this.name = name;
    }

    // Copy constructor
    Food(Food f) {
        this.name = f.name;
    }
}

class Main {
    public static void main(String[] args) {
        Food f1 = new Food("Pizza");
        Food f2 = new Food(f1);   // copy f1 into f2

        System.out.println(f2.name);
    }
}

Output:
Pizza
---

âœ… What is Inheritance in Java?

ðŸ‘‰ Inheritance means one class gets properties (variables) and behavior (methods) from another class.

Basic syntax:
class Child extends Parent {
}

ðŸ“Œ Parent & Child names
   Term	                           Meaning
Parent class	             Super class / Base class
Child class	                 Sub class / Derived class

â­ Why we use inheritance?
âœ” Code reuse
âœ” Less duplication
âœ” Easy maintenance
âœ” Real-world relationship (IS-A)

Example:
Lion IS A Animal âœ”
Car IS A Vehicle âœ”
---

1ï¸âƒ£ Single Inheritance

1ï¸âƒ£ Single Inheritance between TWO CLASSES
ðŸ‘‰ One class extends another class

Example :
class Animal { }

class Lion extends Animal { }

2ï¸âƒ£ Single Inheritance between TWO INTERFACES
ðŸ‘‰ One interface extends another interface

Example:
interface Forest {
   void place();
}

interface IAnimal extends Forest {
   void sleep();
   void eat();
}

3ï¸âƒ£ Single Inheritance between CLASS and INTERFACE

ðŸ‘‰ Class implements ONE interface

Example:
interface Forest {
   void place();
}

class Zoo implements Forest {
   public void place() {
      System.out.println("Animal is in zoo");
   }
}
---

2ï¸âƒ£ Hierarchical Inheritance:

When ONE parent class or interface is inherited by TWO or MORE child classes
ðŸ‘‰ One parent â†’ many children

class Animal { }
class Lion extends Animal { }
class Elephant extends Animal { }

Both Lion & Elephant share Animal features.

child class 1:
class Lion extends Animal {

   public void sound() {
      System.out.println("Lion is roaring");
   }

   public void eat() {
      System.out.println("Lion is eating non-veg");
   }
}

Child class 2:
class Elephant extends Animal {

   public void sound() {
      System.out.println("Elephant is trumpet");
   }

   public void eat() {
      System.out.println("Elephant is eating veg");
   }
}

â–¶ Main method:
public class Test {
   public static void main(String[] args) {

      Lion lion = new Lion();
      lion.sleep();   // from Animal
      lion.sound();  
      lion.eat();

      Elephant ele = new Elephant();
      ele.sleep();   // from Animal
      ele.sound();
      ele.eat();
   }
}
---

3ï¸âƒ£ Multilevel Inheritance

ðŸ‘‰ Parent â†’ Child â†’ Grandchild

Example:
Animal â†’ Lion â†’ Cub

class Animal { }

class Lion extends Animal { }

class Cub extends Lion { }


Cub gets:
âœ” Animal features
âœ” Lion features

example:
1ï¸âƒ£ Parent class
class Animal {

   void breathe() {
      System.out.println("Animal is breathing");
   }
}

2ï¸âƒ£ Child class
class Lion extends Animal {

   void roar() {
      System.out.println("Lion is roaring");
   }
}

3ï¸âƒ£ Grandchild class
class Cub extends Lion {

   void play() {
      System.out.println("Cub is playing");
   }
}

â–¶ Main class
public class Test {
   public static void main(String[] args) {

      Cub cub = new Cub();

      cub.breathe();  // from Animal
      cub.roar();     // from Lion
      cub.play();     // own method
   }
}
---

4ï¸âƒ£ Multiple Inheritance (IMPORTANT in Java)
ðŸ‘‰When a single child class inherits from MORE THAN ONE parent

âš  Java DOES NOT allow multiple inheritance using classes
class C extends A, B  // âŒ

ðŸ‘‰ But Java supports it using interfaces

ðŸ“Š Structure
Interface Animal     Interface Pet
        \               /
             Dog

1ï¸âƒ£ Parent interface 1
interface Animal {
   void eat();
}

2ï¸âƒ£ Parent interface 2
interface Pet {
   void bath();
}

3ï¸âƒ£ Child class
class Dog implements Animal, Pet {

   public void eat() {
      System.out.println("Dog is eating");
   }

   public void bath() {
      System.out.println("Dog is bathing");
   }
}

â–¶ Main class
public class Test {
   public static void main(String[] args) {

      Dog dog = new Dog();

      dog.eat();    // from Animal
      dog.bath();   // from Pet
   }
}

---

    Case	                   Keyword
Class â†’ Class	               extends
Interface â†’ Interface	       extends
Class â†’ Interface	           implements

---

Why final class cannot be inherited in Java?

ðŸ‘‰ Because final means â€œcannot be changed or extendedâ€

Java is saying:
âš  This class is complete
âš  No one is allowed to create a child class from it
---
â“ Why constructors are not inherited?
ðŸ‘‰ Because constructor belongs only to its own class

Its main job is:
->Initialize (set values) of that class object
->Not to pass down to child class.

---

ðŸ” Method Overloading (Compile-time Polymorphism)/(Static Polymorphism)

âœ” Same method name
âœ” Different number or type of parameters
âœ” Happens in same class

Example:
class Calculator {

   int add(int a, int b) {
      return a + b;
   }

   int add(int a, int b, int c) {
      return a + b + c;
   }

   double add(double a, double b) {
      return a + b;
   }
}

---

ðŸ”„ Method Overriding (Runtime Polymorphism)/(Dynamic Polymorphism)

When child class changes the implementation of a parent class method.
(Simple: child modifies parentâ€™s behavior)

âœ” Same method name
âœ” Same parameters
âœ” In inheritance [parent-child class]

Example:
Parent class:
class Animal {
   void sound() {
      System.out.println("Animal makes sound");
   }
}

Child class:
class Dog extends Animal {
   void sound() {
      System.out.println("Dog barks");
   }
}

â–¶ Main:
Animal a = new Dog();
a.sound();

-> Output:
Dog barks //child modifies parentâ€™s behavior

---

ðŸŒˆ Polymorphism

ðŸ‘‰ Polymorphism is used to implement method overloading and method overriding,
where the same method behaves differently based on parameters or object type.

Polymorphism means one method or object behaving in different ways based on situation.

Polymorphism allows a method or object to perform different actions based on context or object type.

-> One method behaves in many forms.

ðŸ“‚ Types of Polymorphism:

1ï¸âƒ£ Compile-time Polymorphism (Static)
ðŸ‘‰ Achieved using Method Overloading

2ï¸âƒ£ Runtime Polymorphism (Dynamic)
ðŸ‘‰ Achieved using Method Overriding

-> static methods cannot be override..if happen that is called "method hiding".
-> final methods cannot be override.
-> Constructors cannot be overridden because they are used to initialize objects 
and their names must match the class name.
---
-> static methods cannot be override..if happen that is called "method hiding"
class Parent {
    static void show() {
        System.out.println("Parent show");
    }
}
class Child extends Parent {
    static void show() {
        System.out.println("Child show");
    }
}
public class Test {
    public static void main(String[] args) {
        Parent obj = new Child();
        obj.show();
    }
}
ðŸ–¨ Output
Parent show

---

1ï¸âƒ£ CONSTRUCTOR 
ðŸ”¹ What is a constructor?
Special method
Same name as class
No return type
Runs automatically when object is created

abstract class Animal {
    Animal() {
        System.out.println("Animal constructor");
    }
}
class Dog extends Animal {
    Dog() {
        System.out.println("Dog constructor");
    }
}
public class Test {
    public static void main(String[] args) {
        Dog d = new Dog();
    }
}
ðŸ–¨ OUTPUT
Animal constructor
Dog constructor

ðŸ§  Why this order?
Parent constructor runs first
Then child constructor

---

2ï¸âƒ£ ABSTRACT METHOD
ðŸ”¹ What is an abstract method?

Method without body
Only declaration
Ends with ;
Forces child class to implement it

-> abstract void eat();

---

3ï¸âƒ£ CONCRETE METHOD (NORMAL METHOD)
ðŸ”¹ What is a concrete method?

Method with body
Can be used directly
Can be overridden (unless final)

âœ… Code
abstract class Animal {
    void sleep() {
        System.out.println("Animal is sleeping");
    }
}

---

--> ABSTRACTION:

Abstraction means hiding implementation details and showing only essential features.
âœ”ï¸ Used to reduce complexity
âœ”ï¸ Improves security
âœ”ï¸ Focuses only on what, not how

ðŸ”· Java supports abstraction in TWO ways
Abstract Class â†’ Partial abstraction (0â€“100%)
Interface â†’ Full abstraction (100%)

---

ðŸ§± Types of Access Modifiers

1ï¸âƒ£ public

Accessible from anywhere
Least restrictive

public class Test {
    public int a = 40;
}

2ï¸âƒ£ private

Accessible only inside the same class
Most restrictive

class Test {
    private int x = 10;
}

3ï¸âƒ£ default (package-private)

No keyword used
Accessible within same package only

class Test {
    int y = 20;   // default access
}
âŒ Not accessible in another package

4ï¸âƒ£protected

Accessible:
Same class
Same package
Subclass in another package (via inheritance)

class Parent {
    protected int z = 30;
}

ðŸ”¹ Class-level access
Only two are allowed:
public
default

public class A { }   // âœ…
class B { }          // âœ…
private class C { }  // âŒ
protected class D { } // âŒ

ðŸ”¹ Method & Variable level
All 4 modifiers are allowed.

-> Private â†’ Class only, 
   Default â†’ Package, 
   Protected â†’ Package + Child(subclass in another package), 
   Public â†’ Everywhere

---
