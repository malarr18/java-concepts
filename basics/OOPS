ğŸ”· What is an Interface in Java?

âœ… Interface in Java â€“ Key Points (Corrected & Simple)

â€¢ Interface is a reference type in Java.

â€¢ It does not have method implementation (only abstract methods).

â€¢ All methods in an interface are abstract by default.

â€¢ We cannot create an object of an interface.

â€¢ Interface is used to achieve 100% abstraction.

â€¢ Interface cannot have a constructor (because no object creation).

â€¢ It supports multiple inheritance.

â€¢ We use the implements keyword to implement an interface in a class.

â€¢ To achieve abstraction in Java, we commonly use interfaces.

â€¢ Interface methods are public by default, so the interface itself cannot be private.


âš¡ Real-time Example (Company based)

Payment System

interface Payment {
    void pay();
}

class GPay implements Payment {
    public void pay() {
        System.out.println("Paid using GPay");
    }
}

class PhonePe implements Payment {
    public void pay() {
        System.out.println("Paid using PhonePe");
    }
}

Interface is used for security by hiding implementation details and exposing only necessary methods.
It provides abstraction, controlled access, and loose coupling, which makes the system safer and flexible.

---

ğŸ”¹ Types of Methods in Java
ğŸ‘‰ Mainly two types:
1ï¸âƒ£ Predefined Method
2ï¸âƒ£ User-defined Method

And inside user-defined methods, we have:

ğŸ‘‰ Static Method
ğŸ‘‰ Instance Method

---

âœ… 1. Predefined Methods (Built-in)

These are already provided by Java.

ğŸ“Œ Examples:
System.out.println();
Math.sqrt(16);


ğŸ‘‰ Created by Java developers
ğŸ‘‰ We just use them

---

âš¡ Static Method

ğŸ‘‰ Belongs to class
ğŸ‘‰ No object needed
ğŸ‘‰ Called using class name

âœ” Example:
class Demo {
    static void display() {
        System.out.println("Static Method");
    }

    public static void main(String[] args) {
        Demo.display();   // no object
    }
}

---

ğŸ‘¤ Instance Method (Non-static)

ğŸ‘‰ Belongs to object
ğŸ‘‰ Object is required
ğŸ‘‰ Called using object

âœ” Example:
class Demo {
    void show() {
        System.out.println("Instance Method");
    }

    public static void main(String[] args) {
        Demo d = new Demo();
        d.show();   // using object
    }
}

---

ğŸ” How is Data Hiding done in Java?

ğŸ‘‰ By using private access modifier

and

ğŸ‘‰ Accessing using public methods (getter & setter)

With Data Hiding (Safe âœ…)
class Account {
    private int balance = 10000; // USE private modifier

    public void setBalance(int amount) {
        if(amount > 0) {
            balance = amount;
        }
    }

    public int getBalance() {
        return balance;
    }
}

Data Hiding is the process of protecting class data by declaring variables as private 
and providing controlled access through public methods(GET AND SET METHODS).

---

ğŸ”’ What is Encapsulation in Java?

Encapsulation = Wrapping data(Instance variable) and behaviour(Instance method) together as a single unit.
and restricting access to variable directly.

Wrapping data (variables) and methods together in one class and protecting the data from direct access.

ğŸ‘‰ We do this by:
Making variables private
Accessing them using public getter and setter methods

âœ… Java Real-Time Example
class BankAccount {

    private int balance;   // hidden data  (instance variable should be private to achieve encapsulation)

    // deposit method
    public void deposit(int amount) {
        if(amount > 0) {
            balance = balance + amount;
        }
    }

    // withdraw method
    public void withdraw(int amount) {
        if(amount <= balance) {
            balance = balance - amount;
        }
    }

    // check balance
    public int getBalance() {
        return balance;
    }
}

â–¶ Using it:
public class Main {
    public static void main(String[] args) {

        BankAccount acc = new BankAccount();

        acc.deposit(1000);
        acc.withdraw(300);

        System.out.println(acc.getBalance()); // 700
    }
}

---

ğŸ”§ What is a Constructor in Java?

ğŸ‘‰ A constructor is a special method that runs automatically when an object is created.

Its main job:
âœ… Initialize values
âœ… Prepare object to use

ğŸ‘‰ Name = class name
ğŸ‘‰ No return type (not even void)

1ï¸âƒ£ Default Constructor (no arguments)

ğŸ‘‰ Automatically called when you create object without values.

âœ” Real life:

Opening app â†’ shows default welcome screen

Java Example:
class Food {
    String name;

    // Default constructor
    Food() {
        name = "Unknown Food";
        System.out.println("Default constructor called");
    }
}

class Main {
    public static void main(String[] args) {
        Food f1 = new Food();   // calls default constructor
        System.out.println(f1.name);
    }
}

Output:
Default constructor called
Unknown Food
---

2ï¸âƒ£ Parameterized Constructor (with values)

ğŸ‘‰ Used to set values while creating object.

âœ” Real life:

Ordering food â†’ you choose name & type

Java Example:
class Food {
    String name;
    int category;

    // Parameterized constructor
    Food(String name, int category) {
        this.name = name;
        this.category = category;
    }
}

class Main {
    public static void main(String[] args) {
        Food f1 = new Food("Dosa", 1);

        System.out.println(f1.name);
        System.out.println(f1.category);
    }
}

Output:
Dosa
1
---

3ï¸âƒ£ Copy Constructor

ğŸ‘‰ Copies data from one object to another.

âœ” Real life:

Re-order same food again ğŸ•

Java Example:
class Food {
    String name;

    // Normal constructor
    Food(String name) {
        this.name = name;
    }

    // Copy constructor
    Food(Food f) {
        this.name = f.name;
    }
}

class Main {
    public static void main(String[] args) {
        Food f1 = new Food("Pizza");
        Food f2 = new Food(f1);   // copy f1 into f2

        System.out.println(f2.name);
    }
}

Output:
Pizza
---

âœ… What is Inheritance in Java?

ğŸ‘‰ Inheritance means one class gets properties (variables) and behavior (methods) from another class.

Basic syntax:
class Child extends Parent {
}

ğŸ“Œ Parent & Child names
   Term	                           Meaning
Parent class	             Super class / Base class
Child class	                 Sub class / Derived class

â­ Why we use inheritance?
âœ” Code reuse
âœ” Less duplication
âœ” Easy maintenance
âœ” Real-world relationship (IS-A)

Example:
Lion IS A Animal âœ”
Car IS A Vehicle âœ”
---

1ï¸âƒ£ Single Inheritance

1ï¸âƒ£ Single Inheritance between TWO CLASSES
ğŸ‘‰ One class extends another class

Example :
class Animal { }

class Lion extends Animal { }

2ï¸âƒ£ Single Inheritance between TWO INTERFACES
ğŸ‘‰ One interface extends another interface

Example:
interface Forest {
   void place();
}

interface IAnimal extends Forest {
   void sleep();
   void eat();
}

3ï¸âƒ£ Single Inheritance between CLASS and INTERFACE

ğŸ‘‰ Class implements ONE interface

Example:
interface Forest {
   void place();
}

class Zoo implements Forest {
   public void place() {
      System.out.println("Animal is in zoo");
   }
}
---

2ï¸âƒ£ Hierarchical Inheritance:

When ONE parent class or interface is inherited by TWO or MORE child classes
ğŸ‘‰ One parent â†’ many children

class Animal { }
class Lion extends Animal { }
class Elephant extends Animal { }

Both Lion & Elephant share Animal features.

child class 1:
class Lion extends Animal {

   public void sound() {
      System.out.println("Lion is roaring");
   }

   public void eat() {
      System.out.println("Lion is eating non-veg");
   }
}

Child class 2:
class Elephant extends Animal {

   public void sound() {
      System.out.println("Elephant is trumpet");
   }

   public void eat() {
      System.out.println("Elephant is eating veg");
   }
}

â–¶ Main method:
public class Test {
   public static void main(String[] args) {

      Lion lion = new Lion();
      lion.sleep();   // from Animal
      lion.sound();  
      lion.eat();

      Elephant ele = new Elephant();
      ele.sleep();   // from Animal
      ele.sound();
      ele.eat();
   }
}
---

3ï¸âƒ£ Multilevel Inheritance

ğŸ‘‰ Parent â†’ Child â†’ Grandchild

Example:
Animal â†’ Lion â†’ Cub

class Animal { }

class Lion extends Animal { }

class Cub extends Lion { }


Cub gets:
âœ” Animal features
âœ” Lion features

example:
1ï¸âƒ£ Parent class
class Animal {

   void breathe() {
      System.out.println("Animal is breathing");
   }
}

2ï¸âƒ£ Child class
class Lion extends Animal {

   void roar() {
      System.out.println("Lion is roaring");
   }
}

3ï¸âƒ£ Grandchild class
class Cub extends Lion {

   void play() {
      System.out.println("Cub is playing");
   }
}

â–¶ Main class
public class Test {
   public static void main(String[] args) {

      Cub cub = new Cub();

      cub.breathe();  // from Animal
      cub.roar();     // from Lion
      cub.play();     // own method
   }
}
---

4ï¸âƒ£ Multiple Inheritance (IMPORTANT in Java)
ğŸ‘‰When a single child class inherits from MORE THAN ONE parent

âš  Java DOES NOT allow multiple inheritance using classes
class C extends A, B  // âŒ

ğŸ‘‰ But Java supports it using interfaces

ğŸ“Š Structure
Interface Animal     Interface Pet
        \               /
             Dog

1ï¸âƒ£ Parent interface 1
interface Animal {
   void eat();
}

2ï¸âƒ£ Parent interface 2
interface Pet {
   void bath();
}

3ï¸âƒ£ Child class
class Dog implements Animal, Pet {

   public void eat() {
      System.out.println("Dog is eating");
   }

   public void bath() {
      System.out.println("Dog is bathing");
   }
}

â–¶ Main class
public class Test {
   public static void main(String[] args) {

      Dog dog = new Dog();

      dog.eat();    // from Animal
      dog.bath();   // from Pet
   }
}

---

    Case	                   Keyword
Class â†’ Class	               extends
Interface â†’ Interface	       extends
Class â†’ Interface	           implements

---

Why final class cannot be inherited in Java?

ğŸ‘‰ Because final means â€œcannot be changed or extendedâ€

Java is saying:
âš  This class is complete
âš  No one is allowed to create a child class from it
---
â“ Why constructors are not inherited?
ğŸ‘‰ Because constructor belongs only to its own class

Its main job is:
->Initialize (set values) of that class object
->Not to pass down to child class.

---

ğŸ” Method Overloading (Compile-time Polymorphism)/(Static Polymorphism)

âœ” Same method name
âœ” Different number or type of parameters
âœ” Happens in same class

Example:
class Calculator {

   int add(int a, int b) {
      return a + b;
   }

   int add(int a, int b, int c) {
      return a + b + c;
   }

   double add(double a, double b) {
      return a + b;
   }
}

---

ğŸ”„ Method Overriding (Runtime Polymorphism)/(Dynamic Polymorphism)

When child class changes the implementation of a parent class method.
(Simple: child modifies parentâ€™s behavior)

âœ” Same method name
âœ” Same parameters
âœ” In inheritance [parent-child class]

Example:
Parent class:
class Animal {
   void sound() {
      System.out.println("Animal makes sound");
   }
}

Child class:
class Dog extends Animal {
   void sound() {
      System.out.println("Dog barks");
   }
}

â–¶ Main:
Animal a = new Dog();
a.sound();

-> Output:
Dog barks //child modifies parentâ€™s behavior

---

ğŸŒˆ Polymorphism

ğŸ‘‰ Polymorphism is used to implement method overloading and method overriding,
where the same method behaves differently based on parameters or object type.

Polymorphism means one method or object behaving in different ways based on situation.

Polymorphism allows a method or object to perform different actions based on context or object type.

-> One method behaves in many forms.

ğŸ“‚ Types of Polymorphism:

1ï¸âƒ£ Compile-time Polymorphism (Static)
ğŸ‘‰ Achieved using Method Overloading

2ï¸âƒ£ Runtime Polymorphism (Dynamic)
ğŸ‘‰ Achieved using Method Overriding

-> static methods cannot be override..if happen that is called "method hiding".
-> final methods cannot be override.
-> Constructors cannot be overridden because they are used to initialize objects 
and their names must match the class name.
---
-> static methods cannot be override..if happen that is called "method hiding"
class Parent {
    static void show() {
        System.out.println("Parent show");
    }
}
class Child extends Parent {
    static void show() {
        System.out.println("Child show");
    }
}
public class Test {
    public static void main(String[] args) {
        Parent obj = new Child();
        obj.show();
    }
}
ğŸ–¨ Output
Parent show

---

1ï¸âƒ£ CONSTRUCTOR 
ğŸ”¹ What is a constructor?
Special method
Same name as class
No return type
Runs automatically when object is created

abstract class Animal {
    Animal() {
        System.out.println("Animal constructor");
    }
}
class Dog extends Animal {
    Dog() {
        System.out.println("Dog constructor");
    }
}
public class Test {
    public static void main(String[] args) {
        Dog d = new Dog();
    }
}
ğŸ–¨ OUTPUT
Animal constructor
Dog constructor

ğŸ§  Why this order?
Parent constructor runs first
Then child constructor

---

2ï¸âƒ£ ABSTRACT METHOD
ğŸ”¹ What is an abstract method?

Method without body
Only declaration
Ends with ;
Forces child class to implement it

-> abstract void eat();

---

3ï¸âƒ£ CONCRETE METHOD (NORMAL METHOD)
ğŸ”¹ What is a concrete method?

Method with body
Can be used directly
Can be overridden (unless final)

âœ… Code
abstract class Animal {
    void sleep() {
        System.out.println("Animal is sleeping");
    }
}

---

--> ABSTRACTION:

Abstraction means hiding implementation details and showing only essential features.
âœ”ï¸ Used to reduce complexity
âœ”ï¸ Improves security
âœ”ï¸ Focuses only on what, not how

ğŸ”· Java supports abstraction in TWO ways
Abstract Class â†’ Partial abstraction (0â€“100%)
Interface â†’ Full abstraction (100%)

Abstract class â†’ can have abstract + concrete methods
Interface â†’ only abstract methods (by default)

1ï¸âƒ£ Abstraction using Abstract Class
âœ… Code
abstract class Animal {

    Animal() {
        System.out.println("Animal constructor");
    }

    abstract void eat();     // abstract method
    abstract void move();    // abstract method

    void sleep() {           // concrete method
        System.out.println("Animal is sleeping");
    }
}

class Dog extends Animal {

    Dog() {
        System.out.println("Dog constructor");
    }

    void eat() {
        System.out.println("Dog is eating");
    }

    void move() {
        System.out.println("Dog is moving");
    }
}

public class Test {
    public static void main(String[] args) {

        Animal a = new Dog();   // parent reference, child object
        a.eat();
        a.move();
        a.sleep();
    }
}

ğŸ–¨ OUTPUT
Animal constructor
Dog constructor
Dog is eating
Dog is moving
Animal is sleeping

-> Abstract class cannot be instantiated
Constructor runs when child object is created
Abstract methods are implemented by child
Concrete method is inherited

2ï¸âƒ£ Abstraction using Interface
âœ… Code
interface Animal {
    void eat();
    void sleep();
}

class Dog implements Animal {

    public void eat() {
        System.out.println("Dog is eating");
    }

    public void sleep() {
        System.out.println("Dog is sleeping");
    }
}

public class Test {
    public static void main(String[] args) {

        Animal a = new Dog();
        a.eat();
        a.sleep();
    }
}

ğŸ–¨ OUTPUT
Dog is eating
Dog is sleeping

Feature	                             Abstract Class                    Interface
Methods	                           Abstract + Concrete	             Only abstract
Constructor                      	âœ… Yes	                           âŒ No
Variables	                         Any type	                    public static final
Multiple inheritance	            âŒ No	                           âœ… Yes
Abstraction	                          Partial	                            Full

---

ğŸ§± Types of Access Modifiers

1ï¸âƒ£ public

Accessible from anywhere
Least restrictive

public class Test {
    public int a = 40;
}

2ï¸âƒ£ private

Accessible only inside the same class
Most restrictive

class Test {
    private int x = 10;
}

3ï¸âƒ£ default (package-private)

No keyword used
Accessible within same package only

class Test {
    int y = 20;   // default access
}
âŒ Not accessible in another package

4ï¸âƒ£protected

Accessible:
Same class
Same package
Subclass in another package (via inheritance)

class Parent {
    protected int z = 30;
}

ğŸ”¹ Class-level access
Only two are allowed:
public
default

public class A { }   // âœ…
class B { }          // âœ…
private class C { }  // âŒ
protected class D { } // âŒ

ğŸ”¹ Method & Variable level
All 4 modifiers are allowed.

-> Private â†’ Class only, 
   Default â†’ Package, 
   Protected â†’ Package + Child(subclass in another package), 
   Public â†’ Everywhere

---

ğŸŒ Real-Time Examples (VERY IMPORTANT â€“ NO ANIMALS)
ğŸ§© Abstraction â€“ ATM Machine

You see: Withdraw, Deposit
You DONâ€™T see: Bank logic, server code
ğŸ‘‰ You know what it does, not how
--
ğŸ¦ Encapsulation â€“ Bank Account

Balance is private
Access only via deposit() / withdraw()
ğŸ‘‰ Data is protected
---
ğŸš— Inheritance â€“ Vehicle System
Vehicle â†’ engine, speed
Car / Bike inherit vehicle features
ğŸ‘‰ Child reuses parent properties
---
ğŸ’³ Polymorphism â€“ Payment System

Pay using UPI
Pay using Debit/Credit Card
Pay using Cash
ğŸ‘‰ Same action, different behavior
---
ğŸ”Œ Interface â€“ Charger / USB Port
Same charging interface
Works for different devices
ğŸ‘‰ Common rule, different implementations
---
ğŸ¦ Method Overriding â€“ Bank Interest

Bank â†’ default interest
SBI â†’ higher interest
HDFC â†’ different interest
ğŸ‘‰ Child provides its own implementation
---
ğŸ” Method Overloading â€“ Login System

Login using Username + Password
Login using Mobile + OTP
ğŸ‘‰ Same method name, different parameters
---
ğŸ§± Class & Object â€“ Mobile Phone

Class â†’ Mobile (design)
Objects â†’ iPhone, Samsung, OnePlus
ğŸ‘‰ Object is real instance of class
---


ğŸŒ ONE STREAM: ONLINE SHOPPING APPLICATION

(Like Amazon / Flipkart)

1ï¸âƒ£ CLASS & OBJECT
ğŸ§± Class

Product, User, Order, Payment

ğŸ§ Object

Product â†’ iPhone

User â†’ Malarvizhi

Payment â†’ UPI

ğŸ‘‰ Object is a real instance of a class

2ï¸âƒ£ ENCAPSULATION â€“ User / Account Details

User details like password, balance are private

Access only via methods like login(), makePayment()

ğŸ‘‰ Data is protected

ğŸ“Œ Real life: You canâ€™t directly change your account balance.

3ï¸âƒ£ ABSTRACTION â€“ Order & Payment Process

User sees:

Add to cart

Place order

Make payment

User DOES NOT see:

Inventory logic

Payment validation

Server communication

ğŸ‘‰ You know what it does, not how

4ï¸âƒ£ INHERITANCE â€“ User Types

User â†’ name, email, login()

Customer â†’ buyProduct()

Admin â†’ addProduct(), removeProduct()

ğŸ‘‰ Child classes reuse parent properties

5ï¸âƒ£ INTERFACE â€“ Payment Gateway

Interface: Payment

Methods: pay()

Implemented by:

UPI

DebitCard

CreditCard

ğŸ‘‰ Common rule, different implementations

6ï¸âƒ£ POLYMORPHISM â€“ Making Payment

Same action: pay()

Different behavior:

pay via UPI

pay via Card

pay via Wallet

ğŸ‘‰ One action, many forms

7ï¸âƒ£ METHOD OVERRIDING â€“ Payment Logic

Payment â†’ pay()

UPI â†’ own implementation

Card â†’ own implementation

ğŸ‘‰ Child changes parent behavior

8ï¸âƒ£ METHOD OVERLOADING â€“ Login / Search

login(email, password)

login(mobile, otp)

ğŸ‘‰ Same method name, different parameters

ğŸ§  ONE-SHOT INTERVIEW ANSWER (YOU CAN SAY THIS)
â€œIn an online shopping application, OOPS concepts are used everywhere. 
User details are protected using encapsulation. 
The order and payment process are abstracted from the user.
Inheritance is used for different user roles like admin and customer. 
Payment is implemented using interfaces, and 
polymorphism allows payment through UPI, card, or wallet using the same method.
Method overloading supports multiple login options.â€
